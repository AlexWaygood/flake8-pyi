# See https://peps.python.org/pep-0484/#positional-only-arguments
# for the full details on which arguments using the older syntax should/shouldn't
# be considered positional-only arguments by type checkers.

def no_args() -> None: ...

def bad(__x: int) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
def also_bad(__x: int, __y: str) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
def still_bad(__x_: int) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments

def okay(__x__: int) -> None: ...
# The first argument isn't positional-only, so logically the second can't be either:
def also_okay(x: int, __y: str) -> None: ...
def fine(x: bytes, /) -> None: ...
def no_idea_why_youd_do_this(__x: int, /, __y: str) -> None: ...

class Foo:
    def bad(__self) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
    @staticmethod
    def bad2(__self) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
    def bad3(__self, __x: int) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
    def still_bad(self, __x_: int) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments
    @staticmethod
    def this_is_bad_too(__x: int) -> None: ...  # Y063 Use PEP-570 syntax to indicate positional-only arguments

    # The first non-self argument isn't positional-only, so logically the second can't be either:
    def okay1(self, x: int, __y: int) -> None: ...
    # Same here:
    @staticmethod
    def okay2(x: int, __y_: int) -> None: ...
    def okay3(__self__, __x__: int, __y: str) -> None: ...
    def okay4(self, /) -> None: ...
    def okay5(self, x: int, /) -> None: ...
    def okay6(__self, /) -> None: ...
